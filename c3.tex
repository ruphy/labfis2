\chapter{Circuiti RC e RL (C3)}

Oggetto di studio di questa esperienza è l'andamento della differenza di potenziale ai capi della resistenza e della capacità (o induttanza) di circuiti RC o RL in corrente impulsata e in corrente alternata.
A tal fine costruiamo un circuito con i seguenti elementi:

\begin{center}
 \includegraphics[scale=0.70]{grafici/C3/schema.png}
\end{center}

\begin{itemize}
  \item Generatore di onde di R= 50 $\Omega$
  \item Un condensatore di capacità 367 $nF$, misurata con il multimetro
  \item Un'induttore di induttanza sconosciuta, e resistenza 40 $\Omega$.
  \item Un oscilloscopio con due sonde
  \item Una resistenza di 677 $\Omega$ 
\end{itemize}

\section{Corrente impulsata: Studio del $\tau$ del circuito}
\subsection{Procedimento}

Per simulare l'apertura e la chiusura del circuito impostiamo nel generatore la modalità onda quadra. Colleghiamo la prima sonda all'ingresso del circuito, subito prima del condensatore: in tal modo l'oscilloscopio confronta il segnale in ingresso con la messa a terra, e visualizza a schermo la differenza di potenziale, restituendo sul display l'onda quadra prodotta dal generatore.  
Analogamente una seconda sonda, posta ai capi della resistenza, visualizza la forma dell'onda caratteristica della carica o della scarica del condensatore/induttore. \\
Raccogliamo i dati campionando dei punti dall'onda visualizzata sul display dell'oscilloscopio, usando i cursori per ottenere la ddp corrispondete all'istante di tempo considerato (si fissa il primo cursore sullo zero e il secondo sul punto dell'onda di cui si vuole conoscere il potenziale: l'oscilloscopio visualizza la differenza tra il potenziale dei due cursori, e dunque la ddp desiderata).
Infine interpoliamo i dati raccolti con le curve caratteristiche della carica per i due differenti circuiti, ricavando il parametro $\tau$ (tempo caratteristico dei circuiti).

\subsubsection{Circuito RC}
Con un'onda quadra a 50 Hz, abbiamo raccolto i seguenti dati:

\begin{center}
\begin{tabular}{*{2}{c}}
Tempo ($\mu s$) & Ddp ($V$) \\
\midrule
0 & 18.20 \\
100 & 12.80 \\
200 & 9.00 \\
300 & 5.80 \\
400 & 4.40 \\
500 & 3.20 \\
600 & 2.20 \\
700 & 1.80 \\
800 & 1.20 \\
900 & 1.00 \\
\end{tabular}
\end{center}

Interpoliamo i dati raccolti con la curva della carica di un condensatore: 
$$V_R = \varepsilon e^{-t/\tau}$$



%Tau per RC
\begin{sagesilent}

rct = np.recfromcsv('dati/C3/RCtau.csv')
tempo = rct['t']
volt = rct['v']
yerr = volt*0.04

def fu(P,x):
    return P[0]*exp((-1./P[1])*x)
    
def fu1(x,v,t):
    return v*exp(-x/t)
    
mymod = odr.Model(fu)
mydata = odr.RealData(tempo,volt)

myodr = odr.ODR(mydata, mymod, beta0=[20.,200.], maxit=5000)
out = myodr.run()

chi = chiquad(tempo,volt,fu1,ysigma=float(0.4),param=[out.beta[0],out.beta[1]])
 
plt.clf()
plt.errorbar(tempo,volt,yerr,np.zeros_like(yerr),'ro')
xin = np.arange(0,1000,10)
yin = fu1(xin,out.beta[0],out.beta[1])
plt.plot(xin,yin,'--')
plt.ylabel(r"$D.d.p$ $(V)$ ")
plt.xlabel(r"$Tempo$ $(\mu s)$")
plt.grid(True)
plt.savefig("grafici/C3/RCtau.png",dpi=300)

\end{sagesilent}


\begin{center}
 \includegraphics[scale=0.70]{grafici/C3/RCtau.png}
\end{center}

Il valore stimato dall'interpolazione è $\tau=\sage{round(out.beta[1],2)}\pm \sage{round(out.sd_beta[1],2)}\ \mu s$.
Valore atteso: $\tau=RC=266.8\ \mu s$, con R=$727\ \Omega$

Nella misura abbiamo riscontrato un errore $\sigma_y= 0.4\ V$.
Per verificare l'accordo tra la legge e la distribuzione dei valori osservati operiamo il test del $\chi^2$:

$$ \chi^2 = \frac{\sum{(y_i - f(x_i,\tau ))}}{\sigma_y^2} $$

Dividendo per i gradi di libertà (7 in questo caso), otteniamo un $\tilde{\chi}^2 = \sage{round(chi,3)}$ \\
Leggiamo dai valori tabulati la probabilità percentuale di ottenere un valore di $\tilde{\chi}^2 \geq {\tilde{\chi}_0}^2 $ (dati i gradi di libertà). Otteniamo una probabilità maggiore del $90\%$, maggiore della soglia di accettabilità, fissata al $5\%$. 


\subsubsection{Circuito RL}
Con un'onda quadra a 250 Hz, abbiamo raccolto i seguenti dati:

\begin{center}
\begin{tabular}{*{2}{c}}
Tempo ($\mu s$) & Ddp ($V$) \\
\midrule
5 & 5.00 \\
10 & 8.00 \\
15 & 10.60 \\
20 & 12.40 \\
25 & 13.60 \\
30 & 14.60 \\
35 & 15.40 \\
40 & 16.20 \\
45 & 16.40 \\
\end{tabular}
\end{center}
Interpoliamo i dati raccolti con la curva caratteristica della carica del circuito:

$$V_R = \varepsilon \left( 1-e^{-t/\tau} \right)$$

%Tau per RL
\begin{sagesilent}
 
rlt = np.recfromcsv('dati/C3/RLtau.csv')
tempo = rlt['t']
volt = rlt['v']
yerr = volt*0.04

def fu(P,x):
    return P[0]*(1-exp((-1./P[1])*x))
    
def fu1(x,v,t):
    return v*(1-exp(-x/t))
    
mymod = odr.Model(fu)
mydata = odr.RealData(tempo,volt)

myodr = odr.ODR(mydata, mymod, beta0=[20.,16.], maxit=5000)
out = myodr.run()

chi = chiquad(tempo,volt,fu1,ysigma=float(0.4),param=[out.beta[0],out.beta[1]])
 
plt.clf()
plt.errorbar(tempo,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(tempo,volt,'ro')
xin = np.arange(min(tempo),1.5*max(tempo),10)
yin = fu1(xin,out.beta[0],out.beta[1])
plt.plot(xin,yin,'b--')
plt.ylabel(r"$D.d.p$ $(V)$ ")
plt.xlabel(r"$Tempo$ $(\mu s)$")
plt.grid(True)
plt.savefig("grafici/C3/RLtau.png",dpi=300)

\end{sagesilent}



Il valore stimato dall'interpolazione è $\tau=\sage{round(out.beta[1],2)} \pm \sage{round(out.sd_beta[1],2)}\mu s$ \\
Non conoscendo a priori il valore di L non possiamo valutare l'accordo con il valore teorico: $\tau=\frac{L}{R}$.

I dati graficati:
\begin{center}
 \includegraphics[scale=0.70]{grafici/C3/RLtau.png}
\end{center}

Otteniamo un valore: $\chi^2 = \sage{round(chi,2)} $. Dati 7 gradi di libertà, $\tilde{\chi}^2 = 0.05$, per un accordo perfetto.


\section{Corrente alternata}
\subsection{Procedimento}
Nella seconda parte dell'esperienza intendiamo misurare la risposta in frequenza (o funzione di trasferimento), definita come:

$H\left(\omega \right) = \begin{cases}
                          |H\left(\omega \right)| \\
                          \text{fase}
                         \end{cases}
$  

Pertanto misuriamo la ddp ai capi di $R$ e $C$ o $L$ in modo analogo alle prima parte dell'esperienza, e la distanza tra due picchi delle onde visualizzate a schermo per determinare l'angolo $\phi$ di sfasamento ($\delta \phi = 2 \pi \Delta t$).

Per ricavare il rapporto $\frac{V_{R}}{V_{o}}$, dobbiamo ricavare $V_R$. Trovandoci in regime di corrente alternata, la leggge di Ohm è nella forma: $ V_o = Zi_o$ con $Z = R + jX$, impedenza del circuito.
Trattandosi di circuiti RC e RL in cui le impedenze sono collegate in serie, si ha $Z_{tot} = \sum Z_i$

\begin{itemize}
\item circuito RC $\rightarrow$ $Z=R-\frac{j}{\omega C}$
\item circuito RL $\rightarrow$ $Z=R+j\omega L$
\end{itemize}  

Allora: 

$$V_{Ro} = Ri_o = \frac{V_o}{Z} = \frac{RV_o}{\sqrt{R^2+X^2}} $$ 


\begin{itemize}
\item circuito RC $\rightarrow$ $X=\frac{1}{\omega C}$
\item circuito RL $\rightarrow$ $X=\omega L$
\end{itemize}

Mentre la fase risulta: 
$$\phi = \arctan \frac{X}{R} $$


\subsection{Circuito RC}


\begin{center}

\begin{tabular}{*{3}{c}}
Frequenza ($Hz$) & $V_{out}/V_{in}$ & $\phi$ \\
\midrule
50 & 0.08 & 1.54\\
100 & 0.15 & 1.41\\
200 & 0.30 & 1.41\\
300 & 0.42 & 1.24\\
400 & 0.52 & 1.08 \\
1000 & 0.83 & 0.70\\
1500 & 0.90 & 0.49\\
2000 & 0.93 & 0.38\\
4000 & 0.97 & 0.20 \\
\end{tabular}
\end{center}

Lasciamo C come parametro libero, e interpoliamo i valori raccolti di $V_{out}$ e $V_{in}$ in funzione della frequenza:

$$\frac{V_{Ro}}{V_o} = \frac{R}{\sqrt{R^2+(\omega C)^{-2}}}$$

%Fit DDP per RC
\begin{sagesilent}

rcf = np.recfromcsv('dati/C3/RCfun.csv')
freq = rcf['frequenza']
freq = freq.astype(float)
volt = rcf['v_out']/rcf['v_in']
yerr = 0.05
xerr = 0

var('x,C')
def funz(x, C):
    return 667/sqrt(667^2+(x*2*n(pi)*C)^(-2))
    
def func(P,x):
    return 667/sqrt(667^2+(x*2*n(pi)*P[0])^(-2))
    
mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)

myodr = odr.ODR(mydata, mymod, beta0=[0.0000001], maxit=5000)
out = myodr.run()

chi = chiquad(freq,volt,funz,ysigma=float(0.01),param=[out.beta[0]])

chir = chi/(len(freq)-1)
 
 
plt.clf()

xin = np.arange(min(freq),1.5*max(freq),10)
yin = funz(xin,out.beta[0])
plt.semilogx(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,xerr,fmt=None)
plt.plot(xin,yin,'b--')
plt.ylabel(r"$D.d.p$ $(V)$ ")
plt.xlabel(r"$Tempo$ $(\mu s)$")
plt.grid(True)
plt.savefig("grafici/C3/RCddp.png",dpi=300)
 
\end{sagesilent}


Dal fit otteniamo: $C=365.42 \pm  6.11\ nF $ in ottimo accordo con il valore noto.

\begin{center}
 \includegraphics[scale=0.70]{grafici/C3/RCddp.png}
\end{center}

Su questo fit si ha un $\chi^2=\sage{round(chi,3)}$, e un $\tilde{\chi}^2 = \sage{round(chir,3)}$, a riflettere un ottimo accordo.

%Fit Phi per RC
\begin{sagesilent}

deltaphi= rcf['frequenza']*rcf['tempo']*2*n(pi)*10^(-6)
yerr = deltaphi*0.06
xerr= 0

var('x,C')
def funz(x, C):
    return arctan(1/(x*2*n(pi)*677*C))
    
def func(P,x):
    return arctan(1/(x*2*n(pi)*677*P[0]))
    
mymod = odr.Model(func)
mydata = odr.RealData(freq,deltaphi)

myodr = odr.ODR(mydata, mymod, beta0=[0.0000001], maxit=5000)
out = myodr.run()

chi = chiquad(freq,deltaphi,funz,ysigma=float(0.1),param=[out.beta[0]])

chir = chi/(len(freq)-1)
 
 
plt.clf()

xin = np.arange(min(freq),1.5*max(freq),10)
yin = funz(xin,out.beta[0])
plt.semilogx(freq,deltaphi,'ro')
plt.errorbar(freq,deltaphi,yerr,xerr,fmt=None)
plt.plot(xin,yin,'b--')
plt.ylabel(r"$\phi (rad)$ ")
plt.xlabel(r"$\nu$ Frequenza $(Hz)$")
plt.grid(True)
plt.savefig("grafici/C3/RCfase.png",dpi=300)
out.pprint()
omega = 1/(677*out.beta[0])
\end{sagesilent}



\begin{center}
 \includegraphics[scale=0.70]{grafici/C3/RCfase.png}
\end{center}

Ora interpolo i dati della $ \phi$ utilizzando la funzione:

$$ \phi = \arctan \frac{1}{2\pi\nu C R} $$

con C parametro libero. $C = 284.47 \pm 10.93\ nF$.
Tramite il test del $\chi^2$ verifico l'accordo con i nostri dati, ottenendo un $\tilde{\chi}^2 = \sage{round(chir,3)}$, a riflettere una probabilità del $43\%$ di ottenere un $\tilde{\chi}^2$ maggiore; dunque il risultato è accettabile.
\\


La frequenza di taglio si definisce come $\omega_c = \frac{1}{RC}$. Nel nostro caso $\omega_c = \sage{round(omega,2)}\ Hz$. 
\\

\subsubsection{Considerazioni teoriche}
Il comportamento del circuito varia a seconda di quanto la nostra frequenza $\omega$ si avvicina al valore della frequenza di taglio. \\
Per frequenze molto basse il carattere capacitivo dell'impedenza domina e pertanto la caduta di potenziale si trova tutta ai capi del condensatore, e la fase $\phi \simeq -\frac{\pi}{2}$. Viceversa per frequenze molto alte, domina il comportamento resistivo e lo sfasamento diviene: $ \phi \simeq 0$. \\  
Per $\omega \simeq \omega_c$, siamo nella transizione tra i due regimi e le impedenze si equivalgono. La fase diviene: $ \phi \simeq -\pi/4$.  \\

L'insieme dei fenomeni da noi osservati in questa secondo parte, ci permette di affermare che il circuito RC da noi costruito agisce come un filtro passa-basso passivo, cioè un filtro che riduce le componenti alle frequenze superiori a quella di taglio (abbattendo l'ampiezza di $V_{out}$ all'aumentare della frequenza, come si vede nel grafico). Il più semplice filtro passa-basso è, infatti, un circuito RC. 

\subsection{Circuito RL}
\begin{center}

\begin{tabular}{*{3}{c}}
Frequenza ($Hz$) & Delta V ($V_{out}/V_{in}$) & $\phi (rad)$ \\
\midrule
1000& 0.47 & 0.19 \\
2000 & 0.62 & 0.35\\
3000 & 0.79 & 0.45\\
4000 & 1.05 & 0.58\\
6000 & 1.48 & 0.79\\
8000 & 2.01 & 1.01\\
10000 & 2.56 & 0.94\\
15000 & 3.64 & 1.13\\
20000 & 4.28 & 1.26\\
30000 & 5.08 & 1.36\\
50000 & 5.89 & 1.57\\
\end{tabular}
\end{center}


Anche questa volta interpoliamo i dati raccolti con la funzione:

$$\frac{V_{Ro}}{V_o} = \frac{R}{\sqrt{R^2+(\omega L)^2}}$$

\begin{center}
 \includegraphics[scale=0.70]{grafici/C3/RLddp.png}
\end{center}

%Fit DDP per RL
\begin{sagesilent}

#Fit del ddp in funzione della frequenza per l'induttore
dati3 = np.recfromcsv('dati/C3/RLfun.csv',delimiter="\t")
dati3 = np.sort(dati3)

deltaV = dati3['v_out']/dati3['v_in']
yerr = 0.1
xerr= 0

var('x,L')

def func(x, L):
    return (667)/(np.sqrt((667+90)^2+(x*2*n(pi)*L)^2)-50)

def fu(P, x):
    return func(x, P[0])
 
import scipy.odr as odr
mymodel = odr.Model(fu)
mydata = odr.RealData(dati3['frequenza'], deltaV)
myodr = odr.ODR(mydata, mymodel, beta0=[0.002],  maxit=1000)
myout = myodr.run()

chiquadrato = chiquad(np.array(dati3['frequenza']), deltaV, fu, ysigma=float(0.05), param=[myout.beta])

plt.clf()
plt.semilogx(dati3['frequenza'],deltaV , 'ro')
xsp = np.arange(0, 500000, 500)
ysp = func(xsp, myout.beta[0])
plt.plot(xsp, ysp, 'b--')
plt.errorbar(dati3['frequenza'],deltaV,yerr,xerr,fmt=None)
plt.grid(True)
plt.ylabel(r"$\frac{V_{out}}{V_{in}}$ ")
plt.xlabel(r"Frequenza $\nu$ - $(Hz)$")
plt.savefig("grafici/C3/RLddp.png", dpi=300)

lstring = "%.4G" % (myout.beta[0]*1000)
lerrorstring = "%.2G" % (myout.sd_beta[0]*1000)
\end{sagesilent}


Da questo fit, otteniamo una $L=\sage{lstring}\pm\sage{lerrorstring}$ mH, e un $\chi^2 = \sage{round(chiquadrato,3)} $, considerando una $\sigma_{y_i} = 2 \pi \nu_i \sigma_{t}$, dove  per $\sigma_t = 2 \mu s$. L'incertezza sulla frequenza è trascurabile, e per questo motivo abbiamo propagato l'incertezza solo su $\sigma_t$. Poichè $\sigma_{y_i}$ è proporzionale alla frequenza, l'incertezza della misura di $\phi$ sulle frequenze più elevate diviene dunque rilevante rendendo possibile accettare un $\chi^2$ così piccolo, pur per un fit che, graficamente, non sembra in buon accordo. Il grafico è inoltre logaritmico, e accentua questo effetto. Le stesse considerazioni valgono per il grafico della $\phi$ per il circuito RC.
\\


%Fit Phi per RL
\begin{sagesilent}

rlf = np.recfromcsv('dati/C3/RLfun.csv',delimiter="\t")
freq = rlf['frequenza']
deltaphi= rlf['frequenza']*rlf['delta']*2*n(pi)*10^(-6)
yerr = deltaphi*0.06
xerr= 0

var('x,L')
def funz(x, L):
    return arctan(x*2*n(pi)*L/677)
    
def func(P,x):
    return arctan(x*2*n(pi)*P[0]/677)
    
mymod = odr.Model(func)
mydata = odr.RealData(freq,deltaphi)

myodr = odr.ODR(mydata, mymod, beta0=[0.012], maxit=1000)
out = myodr.run()

chi = chiquad(freq,deltaphi,funz,ysigma=float(0.1),param=[out.beta[0]])

chir = chi/(len(freq)-1)
 
plt.clf()

xin = np.arange(0.5*min(freq),1.5*max(freq),10)
yin = funz(xin,out.beta[0])
plt.semilogx(freq,deltaphi,'ro')
plt.errorbar(freq,deltaphi,yerr,xerr,fmt=None)
plt.plot(xin,yin,'b--')
plt.ylabel(r"$\phi (rad)$ ")
plt.xlabel(r"$\nu$ Frequenza $(Hz)$")
plt.grid(True)
plt.savefig("grafici/C3/RLfase.png",dpi=300)
out.pprint()
omega = 677/(out.beta[0])

\end{sagesilent}


Interpolo nuovamente i dati, considerando $\phi$, utilizzando la funzione:

$$ \phi = \arctan \frac{2\pi\nu L}{R} $$

dove L è il parametro libero da stimare.

\begin{center}
 \includegraphics[scale=0.70]{grafici/C3/RLfase.png}
\end{center}

$L=\sage{round(out.beta[0],4)}\pm\sage{round(out.sd_beta[0],5)}\ H$ e $\tilde{\chi}^2 = \sage{round(chir,2)}$ con D.o.f =$\sage{len(freq)-1}$
\\

La frequenza di taglio viene definita come $\omega_c = R/L$. Usando la L di questo fit, $\omega_c = \sage{round(omega,2)}\ Hz$. 
\\
\subsubsection{Considerazioni teoriche}
Il comportamento del nostro circuito varia a seconda di quanto la nostra frequenza $\omega$ si avvicina al valore della frequenza di taglio. \\
Per frequenze molto basse il carattere resistivo dell'impedenza domina e pertanto la caduta di potenziale si trova solo ai capi della resistenza; per cui $ \phi \simeq 0$. Viceversa per frequenze molto alte, domina il comportamento induttivo, e lo sfasamento prodotto è simile a quello che introdurrebbe nel circuito un componente puramente induttivo ($\phi \simeq \frac{\pi}{2}$).  \\
Per $\omega = \omega_c$, essendo in transizione tra i due regime, si ha un comportamento intermedio e la fase diviene: $ \phi = \pi/4$. \\

L'insieme dei fenomeni da noi osservati in questa secondo parte, ci permette di affermare che il circuito RL da noi costruito agisce come un filtro passa-alto passivo, cioè un filtro che riduce le componenti alle frequenze inferiori a quella di taglio (abbattendo l'ampiezza di $V_{out}$ al diminuire della frequenza , come si vede nel grafico). Il più semplice filtro passa-alto è, infatti, un circuito RL. 


