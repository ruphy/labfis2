

\chapter{Dati geometrici}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\midrule
\textit{Solenoide} & $n$ & $R_{int}$ & $R_{ext}$ & $R_{medio}$ & $l_{circonferenza}$ & $h$ & $A_{sezione}$  \\
		   & 322 & 0,05	 & 0,0937  & 0,07185 & 0,451446864 & 0,0225 &	0,00098325 \\
 \midrule
\end{tabular}
\end{center}


\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\midrule
\textit{Capacità} & $R_{int}$ (cm) & $R_{ext}$ (cm) & $lunghezza$ (cm) & $spessore piastre$ (cm)\\
   & 5.89 & 3.546  & 40  & 0.31 \\
%?? nel file ods ci sono altre misure per gli stessi campi!
 \midrule
\end{tabular}
\end{center}

\subsubsection{Misura della lunghezza d'onda del laser}

Misuriamo c dalla relazione:
\begin{equation}
 c=\frac{1}{sqrt{LC}}
\end{equation}
pertanto misuriamo la frequenza di risonanza di un cricuito RLC, per differenti configurazioni.


\begin{comment}
Costruiamo un circuito RLC. Nota: il condensatore risente molto delle fluttuazioni, per cui lo colleghiamo a terra, per ridurle il più possibile.

Frequenze di risonanza intorno ai 500 kH (nota: è un minimo -> potenziale ai capi di LC)
\end{comment}

\subparagraph*{Configurazione 1}
%38
\begin{sagesilent}
#Fit per stimare i parametri -> Frequenza di risonanza: -b/2a

#Carico file
raw = np.recfromcsv('dati/EM/par38.csv')

#Seleziono dati per il fit
batch1 = raw[raw['freq']>675]
batch2 = batch1[batch1['freq']< 695]

#Carico negli array i dati giusti
freq = batch2['freq']
volt = batch2['vout']
yerr = batch2['errv']


def funz(x,a,b,c):
    return a*x^2+b*x+c

def func(P,x):
    return funz(x,P[0],P[1],P[2])

mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(freq)-10,max(freq)+10,1)
yin = func(myout.beta,xin)
plt.plot(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

#trovo minimo dai parametri x=-b/2*a
min1 = -myout.beta[1]/(2*myout.beta[0]) 

#stampo minimo su grafico
s = repr(round(min1,2))+" $(Hz)$"
plt.text(680,0.70,s,fontsize=12,bbox=dict(facecolor='red',alpha=0.1))

plt.savefig("grafici/EM/38.png",dpi=300)

\end{sagesilent}


%34
\begin{sagesilent}
 #Fit per stimare i parametri -> Frequenza di risonanza: -b/2a

#Carico file
raw = np.recfromcsv('dati/EM/par34.csv')

#Seleziono dati per il fit
batch1 = raw[raw['freq']>680]
batch2 = batch1[batch1['freq']< 760]

#Carico negli array i dati giusti
freq = batch2['freq']
volt = batch2['vout']
yerr = batch2['errv']


def funz(x,a,b,c):
    return a*x^2+b*x+c

def func(P,x):
    return funz(x,P[0],P[1],P[2])

mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(freq)-10,max(freq)+10,1)
yin = func(myout.beta,xin)
plt.plot(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

#trovo minimo dai parametri x=-b/2*a
min3 = -myout.beta[1]/(2*myout.beta[0])


#stampo minimo su grafico
s = repr(round(min3,2))+" $(Hz)$"
plt.text(680,2,s,fontsize=12,bbox=dict(facecolor='red',alpha=0.1))

plt.savefig("grafici/EM/34.png",dpi=300)
\end{sagesilent}

%32
\begin{sagesilent}
 #Fit per stimare i parametri -> Frequenza di risonanza: -b/2a

#Carico file
raw = np.recfromcsv('dati/EM/par32.csv')

#Seleziono dati per il fit
batch1 = raw[raw['freq']>700]
batch2 = batch1[batch1['freq']< 760]

#Carico negli array i dati giusti
freq = batch2['freq']
volt = batch2['vout']
yerr = batch2['errv']


def funz(x,a,b,c):
    return a*x^2+b*x+c

def func(P,x):
    return funz(x,P[0],P[1],P[2])

mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(freq)-10,max(freq)+10,1)
yin = func(myout.beta,xin)
plt.plot(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

#trovo minimo dai parametri x=-b/2*a
min4 = -myout.beta[1]/(2*myout.beta[0]) 

#stampo minimo su grafico
s = repr(round(min4,2))+" $(Hz)$"
plt.text(725,1.6,s,fontsize=12,bbox=dict(facecolor='red',alpha=0.1))

plt.savefig("grafici/EM/32.png",dpi=300)
\end{sagesilent}

%28
\begin{sagesilent}
 #Fit per stimare i parametri -> Frequenza di risonanza: -b/2a

#Carico file
raw = np.recfromcsv('dati/EM/par28.csv')

#Seleziono dati per il fit
batch1 = raw[raw['freq']>740]
batch2 = batch1[batch1['freq']<800]

#Carico negli array i dati giusti
freq = batch2['freq']
volt = batch2['vout']
yerr = batch2['errv']


def funz(x,a,b,c):
    return a*x^2+b*x+c

def func(P,x):
    return funz(x,P[0],P[1],P[2])

mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(freq)-10,max(freq)+10,1)
yin = func(myout.beta,xin)
plt.plot(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

#trovo minimo dai parametri x=-b/2*a
min5 = -myout.beta[1]/(2*myout.beta[0]) 

#stampo minimo su grafico
s = repr(round(min5,2))+" $(Hz)$"
plt.text(770,1.2,s,fontsize=12,bbox=dict(facecolor='red',alpha=0.1))

plt.savefig("grafici/EM/28.png",dpi=300)
\end{sagesilent}



\includegraphics[scale=0.75]{grafici/EM/38.png}

\includegraphics[scale=0.75]{grafici/EM/34.png}

\includegraphics[scale=0.75]{grafici/EM/32.png}

\includegraphics[scale=0.75]{grafici/EM/28.png}

\begin{comment}
\begin{center}
\sagestr{stampa_dati(dati, r'$\omega$ (rad) & $\V_{out}$ (nm) & $\sigma_{V_{out}}$ (nm)' )}
\end{center}
\end{comment}



\chapter{Analisi con capacità parassite in serie}
\chapter{Analisi con capacità parassite in parallelo}


