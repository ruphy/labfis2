

\chapter{Dati geometrici}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\midrule
\textit{Solenoide} & $n$ & $R_{int}$ & $R_{ext}$ & $R_{medio}$ & $l_{circonferenza}$ & $h$ & $A_{sezione}$  \\
		   & 322 & 0,05	 & 0,0937  & 0,07185 & 0,451446864 & 0,0225 &	0,00098325 \\
 \midrule
\end{tabular}
\end{center}


\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\midrule
\textit{Capacità} & $R_{int}$ (cm) & $R_{ext}$ (cm) & $lunghezza$ (cm) & $spessore piastre$ (cm)\\
   & 5.89 & 3.546  & 40  & 0.31 \\

 \midrule
\end{tabular}
\end{center}

\subsubsection{Misura della lunghezza d'onda del laser}

Misuriamo c dalla relazione:
\begin{equation}
 c=\frac{1}{sqrt{LC}}
\end{equation}
pertanto misuriamo la frequenza di risonanza di un cicuito RLC, per differenti configurazioni del circuito.

\subparagraph*{C ed L}
Nella prima parte dell'esperienza abbiamo verificato che i valori di capacità ed induttanza calcolati a partire dai parametri geometrici corrispondessero effettivamente a quelli misurati in laboratorio. 
Per tanto, in entrambi i circuiti, calcoliamo algebricamente i valori di V e $V_[0]$ per cui $t = \tau$. Inseriamo tali valori e misuriamo i tempo di scarica. Dalla stima del tempo caratteristico ricaviamo L e C. La capacità risulta in accordo, ed è stimata intorno ai $4.38$ nF, l'induttanza invece risulta:

\begin{center}
\begin{tabular}{c c}
$L_{geometrico}$  & 0.000293\\
$L_{misurato}$ & 0.000325\\
\end{tabular}
\end{center}

Visto che è presente una discrepanza tra i valori misurati e quelli geometrici, dovuto a capacità parassite, d'ora in avanti lavoreremo con una induttanza equivalente (modificando un parametro geometrico per ottenere l'accordo): $N_{eq} = 339$


\begin{comment}
Costruiamo un circuito RLC. Nota: il condensatore risente molto delle fluttuazioni, per cui lo colleghiamo a terra, per ridurle il più possibile.

Frequenze di risonanza intorno ai 500 kH (nota: è un minimo -> potenziale ai capi di LC)
\end{comment}

\subparagraph*{Configurazione 1}

\subparagraph*{l=40 cm}

\begin{sagesilent}

 #Fit per stimare i parametri -> Frequenza di risonanza: -b/2a

#Carico file
raw = np.recfromcsv('dati/EM/40.csv')

#Seleziono dati per il fit
batch1 = raw[raw['freq']>640]
batch2 = batch1[batch1['freq']< 695]

#Carico negli array i dati giusti
freq = batch2['freq']
volt = batch2['vout']
yerr = batch2['errv']


def funz(x,a,b,c):
    return a*x^2+b*x+c

def func(P,x):
    return funz(x,P[0],P[1],P[2])

mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(freq)-10,max(freq)+10,1)
yin = func(myout.beta,xin)
plt.plot(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

#trovo minimo dai parametri x=-b/2*a
min1 = -myout.beta[1]/(2*myout.beta[0]) 

#stampo minimo su grafico
s = repr(round(min1,2))+" $(Hz)$"
plt.text(675,1.00,s,fontsize=12,bbox=dict(facecolor='red',alpha=0.1))

plt.savefig("grafici/EM/40.png",dpi=300)
 
\end{sagesilent}

\includegraphics[scale=0.75]{grafici/EM/40.png}

\begin{comment}
\begin{center}
\sagestr{stampa_dati(dati, r'$\omega$ (rad) & $\V_{out}$ (nm) & $\sigma_{V_{out}}$ (nm)' )}
\end{center}
\end{comment}

\subparagraph*{l=38 cm}

\begin{sagesilent}
#Fit per stimare i parametri -> Frequenza di risonanza: -b/2a

#Carico file
raw = np.recfromcsv('dati/EM/par38.csv')

#Seleziono dati per il fit
batch1 = raw[raw['freq']>675]
batch2 = batch1[batch1['freq']< 695]

#Carico negli array i dati giusti
freq = batch2['freq']
volt = batch2['vout']
yerr = batch2['errv']


def funz(x,a,b,c):
    return a*x^2+b*x+c

def func(P,x):
    return funz(x,P[0],P[1],P[2])

mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(freq)-10,max(freq)+10,1)
yin = func(myout.beta,xin)
plt.plot(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

#trovo minimo dai parametri x=-b/2*a
min2 = -myout.beta[1]/(2*myout.beta[0]) 

#stampo minimo su grafico
s = repr(round(min2,2))+" $(Hz)$"
plt.text(685,1.00,s,fontsize=12,bbox=dict(facecolor='red',alpha=0.1))

plt.savefig("grafici/EM/38.png",dpi=300)

\end{sagesilent}

\includegraphics[scale=0.75]{grafici/EM/38.png}

\subparagraph*{l=34 cm}

\begin{sagesilent}
 #Fit per stimare i parametri -> Frequenza di risonanza: -b/2a

#Carico file
raw = np.recfromcsv('dati/EM/par34.csv')

#Seleziono dati per il fit
batch1 = raw[raw['freq']>680]
batch2 = batch1[batch1['freq']< 760]

#Carico negli array i dati giusti
freq = batch2['freq']
volt = batch2['vout']
yerr = batch2['errv']


def funz(x,a,b,c):
    return a*x^2+b*x+c

def func(P,x):
    return funz(x,P[0],P[1],P[2])

mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(freq)-10,max(freq)+10,1)
yin = func(myout.beta,xin)
plt.plot(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

#trovo minimo dai parametri x=-b/2*a
min3 = -myout.beta[1]/(2*myout.beta[0])


#stampo minimo su grafico
s = repr(round(min3,2))+" $(Hz)$"
plt.text(715,1.5,s,fontsize=12,bbox=dict(facecolor='red',alpha=0.1))

plt.savefig("grafici/EM/34.png",dpi=300)
\end{sagesilent}

\includegraphics[scale=0.75]{grafici/EM/34.png}

\subparagraph*{l=32 cm}

\begin{sagesilent}
 #Fit per stimare i parametri -> Frequenza di risonanza: -b/2a

#Carico file
raw = np.recfromcsv('dati/EM/par32.csv')

#Seleziono dati per il fit
batch1 = raw[raw['freq']>700]
batch2 = batch1[batch1['freq']< 760]

#Carico negli array i dati giusti
freq = batch2['freq']
volt = batch2['vout']
yerr = batch2['errv']


def funz(x,a,b,c):
    return a*x^2+b*x+c

def func(P,x):
    return funz(x,P[0],P[1],P[2])

mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(freq)-10,max(freq)+10,1)
yin = func(myout.beta,xin)
plt.plot(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

#trovo minimo dai parametri x=-b/2*a
min4 = -myout.beta[1]/(2*myout.beta[0]) 

#stampo minimo su grafico
s = repr(round(min4,2))+" $(Hz)$"
plt.text(725,1.6,s,fontsize=12,bbox=dict(facecolor='red',alpha=0.1))

plt.savefig("grafici/EM/32.png",dpi=300)
\end{sagesilent}

\includegraphics[scale=0.75]{grafici/EM/32.png}

\subparagraph*{l=28 cm}

\begin{sagesilent}
 #Fit per stimare i parametri -> Frequenza di risonanza: -b/2a

#Carico file
raw = np.recfromcsv('dati/EM/par28.csv')

#Seleziono dati per il fit
batch1 = raw[raw['freq']>740]
batch2 = batch1[batch1['freq']<800]

#Carico negli array i dati giusti
freq = batch2['freq']
volt = batch2['vout']
yerr = batch2['errv']


def funz(x,a,b,c):
    return a*x^2+b*x+c

def func(P,x):
    return funz(x,P[0],P[1],P[2])

mymod = odr.Model(func)
mydata = odr.RealData(freq,volt)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(freq)-10,max(freq)+10,1)
yin = func(myout.beta,xin)
plt.plot(freq,volt,'ro')
plt.errorbar(freq,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

#trovo minimo dai parametri x=-b/2*a
min5 = -myout.beta[1]/(2*myout.beta[0]) 

#stampo minimo su grafico
s = repr(round(min5,2))+" $(Hz)$"
plt.text(765,1.5,s,fontsize=12,bbox=dict(facecolor='red',alpha=0.1))

plt.savefig("grafici/EM/28.png",dpi=300)
\end{sagesilent}

\includegraphics[scale=0.75]{grafici/EM/28.png}



\subsection*{Calcolo di c}

A questo punto fittiamo i valori di $\omega$ raccolti al variare di $l$, lunghezza del condensatore, per ricavare $c$ secondo la relazione:

\begin{equation}
 LC = \frac{1}{{\omega}^2} = l \epsilon_{0} \mu_{0} \frac{n^2 h log(\frac{R_{int}}{R_{ext}})}{log (\frac{b}{a})}
\end{equation}

\begin{sagesilent}

#Fit per il calcolo di c

omega=np.array([min1, min2, min3, min4, min5])
omega.astype(float)
elle=[28, 32, 34, 38, 40]

omegavar=1/omega**2 

def funz(x,a):
    return a*x

def func(P,x):
    return funz(x,P[0])

mymod = odr.Model(func)
mydata = odr.RealData(elle,omegavar)
myfit = odr.ODR(mydata,mymod,beta0=[1.,1.],maxit=1000)
myout = myfit.run()

plt.clf()
xin = np.arange(min(omegavar),max(omegavar),0.001)
yin = func(myout.beta,xin)
plt.plot(elle,omegavar,'ro')
#plt.errorbar(,volt,yerr,np.zeros_like(yerr),fmt=None)
plt.plot(xin,yin,'b--')
plt.grid(True)

plt.savefig("grafici/EM/misurac.png",dpi=300)


\end{sagesilent}

\includegraphics[scale=0.75]{grafici/EM/misurac.png}

%se riesci metti anche l'errore :) ti voglio bene!
\chapter{Analisi con capacità parassite in serie}
\chapter{Analisi con capacità parassite in parallelo}


