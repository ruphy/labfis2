\chapter{Spettrometro (O3)}


\section*{Reticolo}

\subparagraph{Introduzione}

Nella prima parte dell'esperienza misuriamo le lunghezze d'onda corrispondenti a differenti righe spettrali emesse da una sorgente di gas eccitato, attraverso l'uso di un reticolo a diffrazione. \\
Il reticolo a diffrazione consiste in una lastra di vetro su cui sono tracciate delle linee parallele molto sottili. La distanza tra le fenditure dà il passo del reticolo.\\
La luce proveniente dalla sorgente viene fatta passare prima attraverso una fenditura, e successivamente attraverso una lente convergente, il cui piano focale coincide proprio con il piano su cui giace la fenditura: tale sistema prende il nome di collimatore. I raggi paralleli uscenti dalla lente intercettano il reticolo, che attraverso una procedura sperimentale viene posto ortogonalmente al fascio, e da lì vengono deviati di un angolo $\theta$. Un telescopio montato su un piatto rotante permette di osservare le righe d'emissione del gas, ruotando opportunamente la piattaforma secondo la direzione $\theta_{\lambda} $ data dalla legge:
\begin{equation}
\sin (\theta_{\lambda} )= m \frac{\lambda}{d}
\label{eq:theta}
\end{equation}


Da tale legge, dunque possiamo risalire alla lunghezza d'onda, attraverso la lettura dell'angolo di cui si è ruotato il telescopio (la piattaforma è dotata di un goniometro).

\subparagraph{Passo del reticolo}

Prima di iniziare la raccolta dati è necessario posizionare il reticolo in modo tale che risulti perpendicolare al fascio di luce incidente. A tal fine misuriamo gli angoli di deviazione per massimi dello stesso ordine, e lo zero corrisponde alla direzione della luce non deviata. Otteniamo $\theta_{0} = 283^\circ 3' $ \\
Per stabilire il passo del reticolo utilizziamo una sorgente di cui è nota la lunghezza d'onda (lampada a sodio: $\lambda_{Na} = 589.3 $ nm ), e giriamo la \ref{eq:theta} per ricavare d. In particolare utilizziamo una versione della \ref{eq:theta} che diminuisca l'errore sperimentale a cui sono soggette le misure, in cui a $\theta$ si sostituisce la media dei due angoli destro e sinistro $\theta_{dx} $ e $\theta_{sx}$.

\begin{equation}
d = \frac{n \lambda}{\sin(\frac{\theta_{dx}-\theta_{sx}}{2})}
\end{equation}

L'errore su d si ottiene dalla propagazione degli errori associati alla misura degli angoli. Si ha dunque:

\begin{sagesilent}


dati = np.recfromcsv('dati/spettro-reticolo.csv')
var('n')
var('dtheta', latex_name=r'\Delta\theta')
var('lam', latex_name=r'\lambda')
var('sigma_dtheta', latex_name=r'\sigma_{\Delta\theta}')
d(dtheta)=n*lam/(sin(dtheta))
derror = (d.diff())*sigma_dtheta
sigmadth=2*0.0087

dfasterror = fast_float(derror)

def ret_error(dato):
  deltheta = dato['deltatheta']
  res = derror(dtheta=deltheta).subs(lam=dato['lambda']*10^-9, n=int(dato['n']),
                    sigma_dtheta=sigmadth)
  return abs(res[0])
  
errorsarr = np.array([ret_error(dato) for dato in dati ])

dcalc = np.array([float(d.subs(lam=dato['lambda']*10^-9,n=int(dato['n']),dtheta=dato['deltatheta']).n(digits=2) ) for dato in dati ])
dati = ml.rec_append_fields(dati, "d", dcalc*10^6)
dati = ml.rec_append_fields(dati, "error_d", [round(x, 3) for x in errorsarr*10^6])

\end{sagesilent}
$$d:\sage{d}$$
Derivata e moltiplicata per $\sigma_{\Delta\theta}$, otteniamo $\sigma_d$:
$$\sigma_d(\Delta_\theta): \sage{derror}$$
Per i nostri dati:
\begin{center}
\sagestr{stampa_dati(dati, r'n & $\lambda$ (nm) & $\Delta\theta$ (rad) & d ($\mu$m)& $\sigma_d$ ($\mu$m)' )}
\end{center}

\begin{sagesilent}
media = np.average(dati['d'], weights=1./dati['error_d']**2)
errmedia = 1./np.sqrt(sum(1./dati['error_d']**2))
\end{sagesilent}

Otteniamo $d=\sage{round(media, 3)}\pm\sage{round(errmedia, 3)}$ $\mu$m.


\section*{Prisma}


\begin{sagesilent}
#Fit per ricavare i parametri della relazione di Cauchy

dati = np.recfromcsv('dati/spettro-cauchy.csv')

sigmadel=0.0087*0.5
alpha_nostro=1.047

# Calcolo dell'errore

var('n, alpha, x, P')
var('delta', latex_name=r'\delta')
var('sigma_delta', latex_name=r'\sigma_{\delta}')

enne(delta)=sin((alpha+delta)/2)/sin(alpha/2)
derror = (enne.diff())*sigma_delta

def ret_error(dato):
  res = derror(delta=dato['delta']).subs(alpha=alpha_nostro, n=int(dato['n']), sigma_delta=sigmadel)
  return abs(res[0])

errorsarr = np.array([ret_error(dato) for dato in dati ])
dcalc = np.array([enne(delta=dato['delta']).subs(alpha=alpha_nostro, n=int(dato['n'])).n(digits=3) for dato in dati ])

#
# Calcolato l'errore, facciamo il fit
#

l = 1./(dati['l']**2)
n = dati['n']

def func(P,x):
    return P[0]*x+P[1]

odrfit, chi, chiprob = fit_chiquad(l, n, func, init_guess=[1.,1.], ysigma=errorsarr)


# Plot

xin = np.arange(0.9*min(l),1.3*max(l),2*max(l)/10)
yin = func(odrfit.beta, xin)

plt.clf()
plt.plot(xin,yin,'k--')
plt.grid(True,which="both")
plt.errorbar(l,n,errorsarr,np.zeros_like(errorsarr),'b|')
plt.plot(l,n,'ro')

plt.xlabel(r"bubba")
plt.xlabel(r"bubbagiu")
plt.grid(True,which="both")
plt.savefig("grafici/spettro-cauchy.png", dpi=300)

# Rimettiamo i dati nell'array
dati = rf.drop_fields(dati, 'n')
dati = ml.rec_append_fields(dati, "n", [round(x,3) for x in dcalc])
dati = ml.rec_append_fields(dati, "error_d", [round(x, 3) for x in errorsarr])
\end{sagesilent}

Nella seconda parte dell'esperienza intendiamo verificare la legge di Cauchy:
\begin{equation}
n = a + \frac{b}{\lambda^2}
\label{Cauchy}
\end{equation}
che lega l'indice di rifrazione di un materiale alla lunghezza d'onda della luce incidente, nel caso dell'indice di rifrazione di un prisma di vetro.
I coefficienti a e b che figurano in \ref{Cauchy} vengono determinati con il metodo dei minimi quadrati. \\
Pertanto misuriamo n corrispondente alle differenti righe spettrali di una sorgente nota (utilizziamo una lampada Hg come sorgente) attraverso la legge:
\begin{equation}
n = \frac{\sin(\frac{\alpha + \delta}{2})}{sin(\frac{\alpha}{2})}
\label{n}
\end{equation}
in cui $\alpha$ è l'angolo al vertice del prisma, di $60°$, e $\delta$ l'angolo di deviazione minima. Nota: al denominatore del membro di destra si è trascurato di mettere $n_{aria}=1$.\\

Dati raccolti:

\begin{center}
 \sagestr{stampa_dati(dati, r"$\lambda$ teorici (nm) & $\delta$ (rad) & $n$ & $\sigma_n$")}
\end{center}

\begin{center}
\includegraphics[scale=0.75]{grafici/spettro-cauchy.png}
\end{center}

Per le incertezze sugli angoli, sebbene la precisione dello strumento fosse di un secondo d'arco, si è preferito propagare come errore associato alle misure 30'', corrispondenti a 0.00873 rad, in quanto la lettura era spesso difficoltosa (a causa della scarsa luce) e sempre affetta da un leggero errore di parallasse. La propagazione, infine, avviene secondo la legge:
%In cui l'errore su $n$ è dato dall'errore su $\delta = \sage{sigmadel}$ rad tramite la funzione:

$$\sigma_n(\delta): \sage{derror}$$

Dal fit otteniamo i seguenti parametri:

$$a = \sage{round(odrfit.beta[1],4)} \pm \sage{round(odrfit.sd_beta[1],5)}$$
$$b = \sage{int(odrfit.beta[0])} \pm \sage{int(odrfit.sd_beta[0])}$$

Effettuamo il test del ${\chi}^2$ per verificare la bontà delle ipotesi, ed otteniamo:

$$ \chi^ 2 = \sage{chi}$$

Probabilità $\sage{round(chiprob*100, 2)}\%$.


\section*{Determinazione di una sorgente ignota}
Infine utilizziamo i procedimenti e i valori stimati nelle prime parti dell'esperienza  per determinare, mediante lo spettro, il gas corripondente alla sorgente ignota.\\

Calcoliamo n dalla \ref{n}, ed utilizziamo tali valori per ricavare le lunghezze d'onda dalla \ref{Cauchy}, dove adesso sono noti i parametri a e b:
\begin{equation}
\lambda = \sqrt{\frac{b}{n-a}}
\end{equation}


%Elaborazione dati:


\begin{sagesilent}
dati = np.recfromcsv('dati/spettro-neon.csv')

var('alpha')
var('delta', latex_name=r'\delta')
var('sigma_delta', latex_name=r'\sigma_{\delta}')

n(delta) = sin((alpha+delta)/2)/sin(alpha/2)

nerror = (n.diff())*sigma_delta
coeff1=9333.5
coeff2=1.5919

def ret_error(dato):
  res = nerror(delta=dato['delta']).subs(alpha=alpha_nostro, sigma_delta=sigmadel)
  return abs(res[0])
  
errorsarr = np.array([ret_error(dato) for dato in dati ])

ncalc = np.array([float(n(delta=dato['delta']).subs(alpha=alpha_nostro).n(digits=2) ) for dato in dati ])

#Determinazione delle lambda incongite

var('a', 'b')
var('enne', latex_name='n')
var('sigma_a', 'sigma_b')

l(enne)=sqrt(b/(enne-a))

lcalc= np.array([float(l(enne=dato,digits=4).subs(b=coeff1, a=coeff2)  ) for dato in ncalc ])

#Propagazione errori

lerror(a,b)=sqrt(b/(enne-a))
dif = lerror.diff()


nostraa = odrfit.beta[1]
nostrab = odrfit.beta[0]
nostrasigmaa = odrfit.sd_beta[1]
nostrasigmab = odrfit.sd_beta[0]

s_l = sqrt((dif[0]*sigma_a)**2+(dif[1]*sigma_b)**2).subs(a=nostraa, b=nostrab, sigma_a=nostrasigmaa, sigma_b=nostrasigmab)

def errscal(x):
    return s_l.subs(enne=x)

errorl = np.array([float(errscal(trick)) for trick in ncalc ])

teorici = dati['teorici']
dati = rf.drop_fields(dati, 'teorici')
dati = rf.append_fields(dati, "n", ncalc)
dati = ml.rec_append_fields(dati, "error_n", errorsarr)
dati = ml.rec_append_fields(dati, "l", lcalc)
dati = ml.rec_append_fields(dati, "errorl", errorl)
dati = ml.rec_append_fields(dati, "lteorici", teorici)
\end{sagesilent}

$$\sigma_\lambda \sage{sqrt((dif[0]*sigma_a)**2+(dif[1]*sigma_b)**2)}$$

\begin{center}
\sagestr{stampa_dati(dati, r"$\delta$ & $n$ & $\sigma_n$ & $\lambda$ & $\sigma_\lambda$& $\lambda$ teorici") }
\end{center}


%Dal confronto con i valori tabulati otteniamo che l'accordo migliore è con lo spettro del neon. Infatti, come si può osservare:



Le $\lambda$ ottenute dall'elaborazione sono in ottimo accordo con le lunghezze d'onda corrispondenti nello spettro del Neon. Dei valori tabulati per tale elemento si è scelto di affiancare, per il confronto con i nostri dati, quelle con intensità maggiore, talvolta a scapito di un accordo ideale. Il test del ${\chi}^2$ conferma l'ipotesi fatta:

%inserire test chi quadro valori attesi-teorici etc